(function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],t):(e=e||self,t(e.VueGL={},e.THREE))})(this,function(e,t){'use strict';var S=Math.PI;function i(e,t){return i=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},i(e,t)}function a(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],function(){})),!0}catch(t){return!1}}function r(){return r=a()?Reflect.construct:function(e,t,r){var n=[null];n.push.apply(n,t);var a=Function.bind.apply(e,n),s=new a;return r&&i(s,r.prototype),s},r.apply(null,arguments)}function n(e,t){return l(e)||d(e,t)||m()}function s(e){return o(e)||p(e)||c()}function o(e){if(Array.isArray(e)){for(var t=0,a=Array(e.length);t<e.length;t++)a[t]=e[t];return a}}function l(e){if(Array.isArray(e))return e}function p(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}function d(e,t){var i=[],a=!0,r=!1,n=void 0;try{for(var s,o=e[Symbol.iterator]();!(a=(s=o.next()).done)&&(i.push(s.value),!(t&&i.length===t));a=!0);}catch(e){r=!0,n=e}finally{try{a||null==o["return"]||o["return"]()}finally{if(r)throw n}}return i}function c(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function m(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}/**
   * Returns a parsed quaternion object.
   */function u(e){return e.isQuaternion?e:r(t.Quaternion,s(e.trim().split(/\s+/).map(function(e){return parseFloat(e)})))}/**
   * Returns a parsed vector3 object.
   */function g(e){return e.isVector3?e:r(t.Vector3,s(e.trim().split(/\s+/).map(function(e){return parseFloat(e)})))}/**
   * Returns a parsed vector2 object.
   */function h(e){return e.isVector2?e:r(t.Vector2,s(e.trim().split(/\s+/).map(function(e){return parseFloat(e)})))}/**
   * Returns a parsed euler object.
   */function f(e){return e.isEuler?e:r(t.Euler,s(e.trim().split(/\s+/).map(function(e,t){return 3===t?e:parseFloat(e)})))}/**
   * Returns a parsed spherical object.
   */function y(e){return e.isSpherical?e:r(t.Spherical,s(e.trim().split(/\s+/).map(function(e){return parseFloat(e)}))).makeSafe()}/**
   * Returns a parsed array.
   */function b(e){return Array.isArray(e)?e:e.split(",")}/**
   * Returns a parsed array of vector2.
   */function v(e){return b(e).map(function(e){return h(e)})}var x={inject:{vglNamespace:{default:function(){var e,t=this,i=[],a=[];return{renderers:i,cameras:Object.create(null),scenes:Object.create(null),update:function(){e||(t.$nextTick(function(){a.forEach(function(e){e()}),i.forEach(function(e){e.render()}),e=!1}),e=!0)},beforeRender:a,geometries:Object.create(null),materials:Object.create(null),textures:Object.create(null),object3ds:Object.create(null)}}}},provide:function(){return{vglNamespace:Object.create(this.vglNamespace,{geometries:{value:Object.create(this.vglNamespace.geometries)},materials:{value:Object.create(this.vglNamespace.materials)},textures:{value:Object.create(this.vglNamespace.textures)},object3ds:{value:Object.create(this.vglNamespace.object3ds)}})}},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},N=[String,Number],w=String,M=[String,t.Vector3],V=[String,t.Spherical],L=Boolean,A=[String,t.Euler],G=[String,t.Vector2],R=[String,t.Quaternion],C=[String,Array],j=[String,Array],B={props:{/** The object's local position as a 3D vector. */position:M,/** The object's local rotation as a euler angle. */rotation:A,/**
       * The object's local rotation as a quaternion (specified in x, y, z, w order).
       * Do not use in conjunction with the rotation prop, since they both control the same property
       * of the underlying THREE.Object3D object.
       */rotationQuaternion:R,/** The object's local scale as a 3D vector. */scale:M,/** Whether the object gets rendered into shadow map. */castShadow:L,/** Whether the material receives shadows. */receiveShadow:L,/** Optional name of the object. */name:w,/** Whether the object is visible. */visible:{type:L,default:!0}},computed:{inst:function(){return new t.Object3D}},inject:{vglObject3d:{default:{}},vglNamespace:"vglNamespace"},provide:function(){var e=this;return{vglObject3d:{get inst(){return e.inst}}}},created:function(){this.vglNamespace.update()},beforeUpdate:function(){this.vglNamespace.update()},beforeDestroy:function(){var e=this.vglNamespace,t=this.inst,i=this.name;t.parent&&t.parent.remove(t),e.object3ds[i]===t&&delete e.object3ds[i],e.update()},watch:{inst:{handler:function(e,t){t&&t.parent&&t.parent.remove(t),this.vglObject3d.inst&&this.vglObject3d.inst.add(e),this.position&&e.position.copy(g(this.position)),this.rotation&&e.rotation.copy(f(this.rotation)),this.rotationQuaternion&&e.quaternion.copy(u(this.rotationQuaternion)),this.scale&&e.scale.copy(g(this.scale)),Object.assign(e,{castShadow:this.castShadow,receiveShadow:this.receiveShadow,visible:this.visible}),this.name!==void 0&&(this.vglNamespace.object3ds[this.name]=e)},immediate:!0},"vglObject3d.inst":function(e){e.add(this.inst)},position:function(e){this.inst.position.copy(g(e))},rotation:function(e){this.inst.rotation.copy(f(e))},rotationQuaternion:function(e){this.inst.quaternion.copy(u(e))},scale:function(e){this.inst.scale.copy(g(e))},castShadow:function(e){this.inst.castShadow=e},receiveShadow:function(e){this.inst.receiveShadow=e},name:function(e,t){var i=this.vglNamespace.object3ds,a=this.inst;i[t]===a&&delete i[t],i[e]=a},visible:function(e){this.inst.visible=e}},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},z={mixins:[B],props:{/**
       * Position in 3D space for the camera to point towards.
       * This property overwrite rotation property when both defined.
       */orbitTarget:M,/**
       * Spherical position around orbitTarget.
       * This property overwrite position and rotation properties.
       * If orbitTarget is not defined, automatically set to (0, 0, 0).
       */orbitPosition:V},computed:{inst:function(){return new t.Camera}},watch:{inst:{handler:function(e){if(this.vglNamespace.cameras[this.name]=e,this.orbitPosition||this.orbitTarget){var i;this.orbitTarget&&(i=g(this.orbitTarget)),this.orbitPosition&&(e.position.setFromSpherical(y(this.orbitPosition)),i&&e.position.add(i)),e.lookAt(i||new t.Vector3)}},immediate:!0},name:function(e,t){var i=this.vglNamespace.cameras,a=this.inst;i[t]===a&&delete i[t],i[e]=a},orbitTarget:function(e){var t=g(e);this.orbitPosition&&this.inst.position.setFromSpherical(y(this.orbitPosition)).add(t),this.inst.lookAt(t)},orbitPosition:function(e){if(this.inst.position.setFromSpherical(y(e)),this.orbitTarget){var i=g(this.orbitTarget);this.inst.position.add(i),this.inst.lookAt(i)}else this.inst.lookAt(new t.Vector3)}},beforeDestroy:function(){var e=this.vglNamespace.cameras,t=this.inst;e[this.name]===t&&delete e[this.name]}},D={mixins:[B],props:{/** CSS style color of the light. */color:{type:w,default:"#fff"},/** Numeric value of the light's strength/intensity. */intensity:{type:N,default:1}},computed:{inst:function(){return new t.Light}},watch:{inst:{handler:function(e){e.color.setStyle(this.color),Object.assign(e,{intensity:parseFloat(this.intensity)})},immediate:!0},color:function(e){this.inst.color.setStyle(e)},intensity:function(e){this.inst.intensity=parseFloat(e)}}},P={no:t.NoColors,vertex:t.VertexColors,face:t.FaceColors},T={front:t.FrontSide,back:t.BackSide,double:t.DoubleSide},H={inject:["vglNamespace"],props:{/** Name of the material. */name:w,/** Defines which side of faces will be rendered. front, back or double. */side:{type:w,default:"front"},/** Defines whether vertex coloring is used. Other options are 'vertex' and 'face'. */vertexColors:{type:w,default:"no"}},computed:{inst:function(){return new t.Material}},watch:{inst:{handler:function(e){e.setValues({side:T[this.side],vertexColors:P[this.vertexColors]}),this.vglNamespace.materials[this.name]=e},immediate:!0},name:function(e,t){var i=this.vglNamespace.materials,a=this.inst;i[t]===a&&delete i[t],i[e]=a},side:function(e){this.inst.side=T[e]},vertexColors:function(e){this.inst.vertexColors=P[e]}},beforeDestroy:function(){var e=this.vglNamespace.materials,t=this.inst;e[this.name]===t&&delete e[this.name]},created:function(){this.vglNamespace.update()},beforeUpdate:function(){this.vglNamespace.update()},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},F={inject:["vglNamespace"],props:{/** Name of the component. */name:w,/** The x, y, and z coordinates of each vertex in this geometry. */positionAttribute:C,/** The red, green, and blue channels of vertex color of each vertex in this geometry. */colorAttribute:C,/** The x, y, and z components of the vertex normal vector of each vertex in this geometry. */normalAttribute:C},computed:{inst:function(){return new t.BufferGeometry}},watch:{inst:{handler:function(e,i){if(this.positionAttribute){var a=i?i.getAttribute("position"):new t.BufferAttribute(new Float32Array(b(this.positionAttribute)),3);e.addAttribute("position",a)}if(this.colorAttribute){var r=i?i.getAttribute("color"):new t.BufferAttribute(new Float32Array(b(this.colorAttribute)),3);e.addAttribute("color",r)}if(this.normalAttribute){var n=i?i.getAttribute("normal"):new t.BufferAttribute(new Float32Array(b(this.normalAttribute)),3);e.addAttribute("normal",n)}i&&i.dispose(),this.vglNamespace.geometries[this.name]=e},immediate:!0},name:function(e,t){var i=this.vglNamespace.geometries,a=this.inst;i[t]===a&&delete i[t],i[e]=a},positionAttribute:function(e){var t=b(e),i=this.inst.getAttribute("position");i.array.length===t.length?i.copyArray(t):i.setArray(new Float32Array(t)),i.needsUpdate=!0},colorAttribute:function(e){var t=b(e),i=this.inst.getAttribute("color");i.array.length===t.length?i.copyArray(t):i.setArray(new Float32Array(t)),i.needsUpdate=!0},normalAttribute:function(e){var t=b(e),i=this.inst.getAttribute("normal");i.array.length===t.length?i.copyArray(t):i.setArray(new Float32Array(t)),i.needsUpdate=!0}},beforeDestroy:function(){var e=this.vglNamespace.geometries,t=this.inst;e[this.name]===t&&delete e[this.name],t.dispose()},created:function(){this.vglNamespace.update()},beforeUpdate:function(){this.vglNamespace.update()},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},E={mixins:[B],methods:{setMaterial:function(){var e=this.vglNamespace.materials,t=this.material,i=this.inst;e[t]&&(i.material=e[t])}},created:function(){this.vglNamespace.beforeRender.unshift(this.setMaterial)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setMaterial;e.splice(e.indexOf(t),1)}},O={mixins:[E],methods:{setGeometry:function(){var e=this.vglNamespace.geometries,t=this.geometry,i=this.inst;e[t]&&(i.geometry=e[t])}},created:function(){this.vglNamespace.beforeRender.unshift(this.setGeometry)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setGeometry;e.splice(e.indexOf(t),1)}},$={mixins:[H],methods:{setMap:function(){var e=this.vglNamespace.textures,t=this.inst,i=this.map;i in e&&(t.map=e[i])}},created:function(){this.vglNamespace.beforeRender.unshift(this.setMap)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setMap;e.splice(e.indexOf(t),1)}},k={mixins:[$],props:{/** CSS style color of the material. */color:{type:w,default:"#fff"},/** The color map of the material. */map:w},computed:{inst:function(){return new t.MeshStandardMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)}}},U={mixins:[O],props:{/** Name of the geometry, representing the line segment(s). */geometry:w,/** Name of the material for the line. */material:w},computed:{inst:function(){return new t.Line}},methods:{computeLineDistances:function(){this.inst.material.isLineDashedMaterial&&this.inst.computeLineDistances()}},created:function(){this.vglNamespace.beforeRender.push(this.computeLineDistances)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.computeLineDistances;e.splice(e.indexOf(t),1)}},W={mixins:[F],props:{/** Radius of the cylinder at the top. */radiusTop:{type:N,default:1},/** Radius of the cylinder at the bottom. */radiusBottom:{type:N,default:1},/** Height of the cylinder. */height:{type:N,default:1},/** Number of segmented faces around the circumference of the cylinder. */radialSegments:{type:N,default:8},/** Number of rows of faces along the height of the cylinder. */heightSegments:{type:N,default:1},/** A Boolean indicating whether the ends of the cylinder are open or capped. */openEnded:L,/** Start angle for first segment. */thetaStart:{type:N,default:0},/** The central angle of the circular sector. */thetaLength:{type:N,default:2*S}},computed:{inst:function(){return new t.CylinderBufferGeometry(parseFloat(this.radiusTop),parseFloat(this.radiusBottom),parseFloat(this.height),parseInt(this.radialSegments,10),parseInt(this.heightSegments,10),this.openEnded,parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},_={uv:t.UVMapping,"cube-reflection":t.CubeReflectionMapping,"cube-refraction":t.CubeRefractionMapping,"equirectangular-reflection":t.EquirectangularReflectionMapping,"equirectangular-refraction":t.EquirectangularRefractionMapping,"spherical-reflection":t.SphericalReflectionMapping,"cube-uv-reflection":t.CubeUVReflectionMapping,"cube-uv-refraction":t.CubeUVRefractionMapping},I={repeat:t.RepeatWrapping,"clamp-to-edge":t.ClampToEdgeWrapping,"mirrored-repeat":t.MirroredRepeatWrapping},q={nearest:t.NearestFilter,"nearest-mip-map-nearest":t.NearestMipMapNearestFilter,"nearest-mip-map-linear":t.NearestMipMapLinearFilter,linear:t.LinearFilter,"linear-mip-map-nearest":t.LinearMipMapNearestFilter,"linear-mip-map-linear":t.LinearMipMapLinearFilter},Q={alpha:t.AlphaFormat,rgb:t.RGBFormat,rgba:t.RGBAFormat,luminance:t.LuminanceFormat,"luminance-alpha":t.LuminanceAlphaFormat,rgbe:t.RGBEFormat,depth:t.DepthFormat,"depth-stencil":t.DepthStencilFormat},K={"unsigned-byte":t.UnsignedByteType,byte:t.ByteType,short:t.ShortType,"unsigned-short":t.UnsignedShortType,int:t.IntType,"unsigned-int":t.UnsignedIntType,float:t.FloatType,"half-float":t.HalfFloatType,"unsigned-short-4444":t.UnsignedShort4444Type,"unsigned-short-5551":t.UnsignedShort5551Type,"unsigned-short-565":t.UnsignedShort565Type,"unsigned-int-248":t.UnsignedInt248Type},J={linear:t.LinearEncoding,"s-rgb":t.sRGBEncoding,gamma:t.GammaEncoding,rgbe:t.RGBEEncoding,"log-luv":t.LogLuvEncoding,rgbm7:t.RGBM7Encoding,rgbm16:t.RGBM16Encoding,rgbde:t.RGBDEncoding,"basic-depth":t.BasicDepthPacking,"rgba-depth":t.RGBADepthPacking},X={mixins:[F],computed:{inst:function(){return new t.ExtrudeBufferGeometry([],{})}}},Y=Object.create(null),Z={mixins:[$],props:{/** CSS style color of the material. */color:{type:w,default:"#fff"},/** The color map of the material. */map:w,/** Specular color of the material. */specular:{type:w,default:"#111111"},/** How shiny the specular highlight is. A higher value gives a sharper highlight. */shininess:{type:N,default:30}},computed:{inst:function(){return new t.MeshPhongMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{shininess:parseFloat(this.shininess)}),e.specular.setStyle(this.specular),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)},specular:function(e){this.inst.specular.setStyle(e)},shininess:function(e){this.inst.shininess=parseFloat(e)}}};e.VglNamespace=x,e.VglObject3d=B,e.VglScene={mixins:[B],computed:{inst:function(){return new t.Scene}},watch:{inst:{handler:function(e){this.vglNamespace.scenes[this.name]=e},immediate:!0},name:function(e,t){var i=this.vglNamespace.scenes,a=this.inst;i[t]===a&&delete i[t],i[e]=a}},beforeDestroy:function(){var e=this.vglNamespace.scenes,t=this.inst;e[this.name]===t&&delete e[this.name]}},e.VglCamera=z,e.VglRenderer={mixins:[x],props:{/** Shader precision. Can be "highp", "mediump" or "lowp". */precision:w,/** Whether the canvas contains an alpha (transparency) buffer or not. */alpha:L,/** Whether the renderer will assume that colors have premultiplied alpha. */disablePremultipliedAlpha:L,/** Whether to perform antialiasing. */antialias:L,/** Whether the drawing buffer has a stencil buffer of at least 8 bits. */disableStencil:L,/**
       * A hint to the user agent indicating what configuration of GPU is suitable
       * for this WebGL context. Can be "high-performance", "low-power" or "default".
       */powerPreference:w,/** Whether to preserve the buffers until manually cleared or overwritten. */preserveDrawingBuffer:L,/** Whether the drawing buffer has a depth buffer of at least 16 bits. */disableDepth:L,/** Whether to use a logarithmic depth buffer. */logarithmicDepthBuffer:L,/** Name of the using camera. */camera:w,/** Name of the target scene. */scene:w,/** If set, use shadow maps in the scene. */shadowMapEnabled:L},computed:{inst:function e(){var e=new t.WebGLRenderer({precision:this.precision,alpha:this.alpha,premultipliedAlpha:!this.disablePremultipliedAlpha,antialias:this.antialias,stencil:!this.disableStencil,preserveDrawingBuffer:this.preserveDrawingBuffer,depth:!this.disableDepth,logarithmicDepthBuffer:this.logarithmicDepthBuffer,powerPreference:this.powerPreference});return e.shadowMap.enabled=this.shadowMapEnabled,e},cameraInst:function(){if(this.camera!==void 0)return this.vglNamespace.cameras[this.camera];var e;// eslint-disable-next-line guard-for-in, no-restricted-syntax
for(var t in this.vglNamespace.cameras){if(e)throw new ReferenceError("Cannot identify the camera. camera prop must be set when multiple cameras are defined.");e=this.vglNamespace.cameras[t]}return e},sceneInst:function(){if(this.scene!==void 0)return this.vglNamespace.scenes[this.scene];var e;// eslint-disable-next-line guard-for-in, no-restricted-syntax
for(var t in this.vglNamespace.scenes){if(e)throw new ReferenceError("Cannot identify the scene. scene prop must be set when multiple scenes are defined.");e=this.vglNamespace.scenes[t]}return e}},methods:{render:function(){var e=this.inst,t=this.cameraInst,i=this.sceneInst;if(t&&i){if(t.isPerspectiveCamera){var a=this.$el.clientWidth/this.$el.clientHeight;t.aspect!==a&&(t.aspect=a,t.updateProjectionMatrix())}else if(t.isOrthographicCamera){var r=this.$el.clientWidth/2,n=this.$el.clientHeight/2;(t.right!==r||t.top!==n)&&(t.left=-r,t.right=r,t.top=n,t.bottom=-n,t.updateProjectionMatrix())}else throw new TypeError("Unknown camera type.");e.render(i,t)}}},watch:{inst:function(e,t){this.$el&&(e.setSize(this.$el.clientWidth,this.$el.clientHeight),this.$el.replaceChild(e.domElement,t.domElement),this.vglNamespace.update()),t.dispose()}},created:function(){this.vglNamespace.renderers.push(this)},mounted:function(){this.inst.setSize(this.$el.clientWidth,this.$el.clientHeight),this.$el.appendChild(this.inst.domElement),this.vglNamespace.update()},beforeDestroy:function(){this.vglNamespace.renderers.splice(this.vglNamespace.renderers.indexOf(this),1),this.inst.dispose()},render:function(e){var t=this;return e("div",[e("iframe",{style:{visibility:"hidden",width:"100%",height:"100%",marginRight:"-100%",border:"none"},on:{load:function(e){e.target.contentWindow.addEventListener("resize",function(){t.inst.setSize(t.$el.clientWidth,t.$el.clientHeight),t.vglNamespace.update()},!1)}}},this.$slots.default)])}},e.VglPerspectiveCamera={mixins:[z],props:{/** Zoom factor of the camera. */zoom:{type:N,default:1},/** Camera frustum near plane. */near:{type:N,default:.1},/** Camera frustum far plane. */far:{type:N,default:2e3},/** Camera frustum vertical field of view, from bottom to top of view, in degrees. */fov:{type:N,default:50}},computed:{inst:function(){return new t.PerspectiveCamera}},watch:{inst:{handler:function(e){Object.assign(e,{zoom:parseFloat(this.zoom),near:parseFloat(this.near),far:parseFloat(this.far),fov:parseFloat(this.fov)}),e.updateProjectionMatrix()},immediate:!0},zoom:function(e){this.inst.zoom=parseFloat(e),this.inst.updateProjectionMatrix()},near:function(e){this.inst.near=parseFloat(e),this.inst.updateProjectionMatrix()},far:function(e){this.inst.far=parseFloat(e),this.inst.updateProjectionMatrix()},fov:function(e){this.inst.fov=parseFloat(e),this.inst.updateProjectionMatrix()}}},e.VglGroup={mixins:[B],computed:{inst:function(){return new t.Group}}},e.VglLight=D,e.VglDirectionalLight={mixins:[D],computed:{inst:function(){return new t.DirectionalLight}}},e.VglAmbientLight={mixins:[D],computed:{inst:function(){return new t.AmbientLight}}},e.VglMaterial=H,e.VglPointsMaterial={mixins:[H],props:{/** CSS style color of the material. */color:{type:w,default:"#fff"},/** The size of the points. */size:{type:N,default:1},/** Specify whether points' size will get smaller with the distance. */disableSizeAttenuation:L},computed:{inst:function(){return new t.PointsMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{size:parseFloat(this.size),sizeAttenuation:!this.disableSizeAttenuation}),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)},size:function(e){this.inst.size=parseFloat(e)},disableSizeAttenuation:function(e){this.inst.sizeAttenuation=!e}}},e.VglGeometry=F,e.VglSphereGeometry={mixins:[F],props:{/** Sphere radius. */radius:{type:N,default:1},/** Number of horizontal segments. */widthSegments:{type:N,default:8},/** Number of vertical segments. */heightSegments:{type:N,default:6},/** Specify horizontal starting angle. */phiStart:{type:N,default:0},/** Specify horizontal sweep angle size. */phiLength:{type:N,default:2*S},/** Specify vertical starting angle. */thetaStart:{type:N,default:0},/** Specify vertical sweep angle size. */thetaLength:{type:N,default:S}},computed:{inst:function(){return new t.SphereBufferGeometry(parseFloat(this.radius),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10),parseFloat(this.phiStart),parseFloat(this.phiLength),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglMeshStandardMaterial=k,e.VglMesh={mixins:[O],props:{/** Name of the geometry, defining the object's structure. */geometry:w,/** Name of the material, defining the object's appearance. */material:w},computed:{inst:function(){return new t.Mesh}}},e.VglPoints={mixins:[O],props:{/** Name of the geometry, defining the object's structure. */geometry:w,/** Name of the material, defining the object's appearance. */material:w},computed:{inst:function(){return new t.Points}}},e.VglLineBasicMaterial={mixins:[H],props:{/** CSS style color of the material. */color:{type:w,default:"#fff"},/** A boolean whether the material is affected by lights. */lights:L,/** The line thickness. */linewidth:{type:N,default:1},/** Define appearance of line ends. Possible values are "butt", "round" and "square". */linecap:{type:w,default:"round"},/** Define appearance of line joints. Possible values are "round", "bevel" and "miter". */linejoin:{type:w,default:"round"}},computed:{inst:function(){return new t.LineBasicMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{lights:this.lights,linecap:this.linecap,linejoin:this.linejoin,linewidth:parseFloat(this.linewidth)}),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)},lights:function(e){this.inst.lights=e},linewidth:function(e){this.inst.linewidth=parseFloat(e)},linecap:function(e){this.inst.linecap=e},linejoin:function(e){this.inst.linejoin=e}}},e.VglLine=U,e.VglSprite={mixins:[E],props:{/** Name of the material, defining the object's appearance. */material:w},computed:{inst:function(){return new t.Sprite}}},e.VglBoxGeometry={mixins:[F],props:{/** Width of the sides on the X axis. */width:{type:N,default:1},/** Height of the sides on the Y axis. */height:{type:N,default:1},/** Depth of the sides on the Z axis. */depth:{type:N,default:1},/** Number of segmented faces along the width of the sides. */widthSegments:{type:N,default:1},/** Number of segmented faces along the height of the sides. */heightSegments:{type:N,default:1},/** Number of segmented faces along the depth of the sides. */depthSegments:{type:N,default:1}},computed:{inst:function(){return new t.BoxBufferGeometry(parseFloat(this.width),parseFloat(this.height),parseFloat(this.depth),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10),parseInt(this.depthSegments,10))}}},e.VglCircleGeometry={mixins:[F],props:{/** Radius of the circle. */radius:{type:N,default:1},/** Number of segments (triangles). */segments:{type:N,default:8},/** Start angle for first segment. */thetaStart:{type:N,default:0},/** The central angle of the circular sector. */thetaLength:{type:N,default:2*S}},computed:{inst:function(){return new t.CircleBufferGeometry(parseFloat(this.radius),parseInt(this.segments,10),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglLineSegments={mixins:[U],computed:{inst:function(){return new t.LineSegments}}},e.VglLineLoop={mixins:[U],computed:{inst:function(){return new t.LineLoop}}},e.VglConeGeometry={mixins:[W],props:{/** Radius of the cone at the base. */radius:{type:N,default:1}},computed:{inst:function(){return new t.ConeBufferGeometry(parseFloat(this.radius),parseFloat(this.height),parseInt(this.radialSegments,10),parseInt(this.heightSegments,10),this.openEnded,parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglAxesHelper={mixins:[B],props:{/** Size of the lines representing the axes. */size:{type:N,default:1}},computed:{inst:function(){return new t.AxesHelper(parseFloat(this.size))}}},e.VglOrthographicCamera={mixins:[z],props:{/** Zoom factor of the camera. */zoom:{type:N,default:1},/** Camera frustum near plane. */near:{type:N,default:.1},/** Camera frustum far plane. */far:{type:N,default:2e3}},computed:{inst:function(){return new t.OrthographicCamera}},watch:{inst:{handler:function(e){Object.assign(e,{zoom:parseFloat(this.zoom),near:parseFloat(this.near),far:parseFloat(this.far)}),e.updateProjectionMatrix()},immediate:!0},zoom:function(e){this.inst.zoom=parseFloat(e),this.inst.updateProjectionMatrix()},near:function(e){this.inst.near=parseFloat(e),this.inst.updateProjectionMatrix()},far:function(e){this.inst.far=parseFloat(e),this.inst.updateProjectionMatrix()}}},e.VglCylinderGeometry=W,e.VglPlaneGeometry={mixins:[F],props:{/** Width along the X axis. */width:{type:N,default:1},/** Height along the Y axis. */height:{type:N,default:1},/** Number of segments along the X axis. */widthSegments:{type:N,default:1},/** Number of segments along the Y axis. */heightSegments:{type:N,default:1}},computed:{inst:function(){return new t.PlaneBufferGeometry(parseFloat(this.width),parseFloat(this.height),parseInt(this.widthSegments,10),parseInt(this.heightSegments,10))}}},e.VglDodecahedronGeometry={mixins:[F],props:{/** Radius of the dodecahedron. */radius:{type:N,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a dodecahedron. */detail:{type:N,default:0}},computed:{inst:function(){return new t.DodecahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglIcosahedronGeometry={mixins:[F],props:{/** Radius of the icosahedron. */radius:{type:N,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a icosahedron. */detail:{type:N,default:0}},computed:{inst:function(){return new t.IcosahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglOctahedronGeometry={mixins:[F],props:{/** Radius of the octahedron. */radius:{type:N,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a octahedron. */detail:{type:N,default:0}},computed:{inst:function(){return new t.OctahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglRingGeometry={mixins:[F],props:{/** Inner radius of the ring. */innerRadius:{type:N,default:.5},/** Outer radius of the ring. */outerRadius:{type:N,default:1},/** Number of segments along to the tangential direction. */thetaSegments:{type:N,default:8},/** Number of segments along to the radial direction. */phiSegments:{type:N,default:1},/** The starting angle. */thetaStart:{type:N,default:0},/** The central angle. */thetaLength:{type:N,default:2*S}},computed:{inst:function(){return new t.RingBufferGeometry(parseFloat(this.innerRadius),parseFloat(this.outerRadius),parseInt(this.thetaSegments,10),parseInt(this.phiSegments,10),parseFloat(this.thetaStart),parseFloat(this.thetaLength))}}},e.VglTetrahedronGeometry={mixins:[F],props:{/** Radius of the tetrahedron. */radius:{type:N,default:1},/** Setting this to a value greater than 0 adds vertices making it no longer a tetrahedron. */detail:{type:N,default:0}},computed:{inst:function(){return new t.TetrahedronBufferGeometry(parseFloat(this.radius),parseInt(this.detail,10))}}},e.VglTorusGeometry={mixins:[F],props:{/** Radius of the torus. */radius:{type:N,default:1},/** Diamiter of the tube. */tube:{type:N,default:.4},/** Number of segments of the tube's section. */radialSegments:{type:N,default:8},/** Number of segments along to the tube length direction. */tubularSegments:{type:N,default:6},/** The central angle. */arc:{type:N,default:2*S}},computed:{inst:function(){return new t.TorusBufferGeometry(parseFloat(this.radius),parseFloat(this.tube),parseInt(this.radialSegments,10),parseInt(this.tubularSegments,10),parseFloat(this.arc))}}},e.VglTorusKnotGeometry={mixins:[F],props:{/** Radius of the torus. */radius:{type:N,default:1},/** Diamiter of the tube. */tube:{type:N,default:.4},/** Number of segments of the tube's section. */radialSegments:{type:N,default:8},/** Number of segments along to the tube length direction. */tubularSegments:{type:N,default:64},/**
       * This value determines how many times the geometry winds
       * around its axis of rotational symmetry.
       */p:{type:N,default:2},/**
       * This value determines how many times the geometry winds
       * around a circle in the interior of the torus.
       */q:{type:N,default:3}},computed:{inst:function(){return new t.TorusKnotBufferGeometry(parseFloat(this.radius),parseFloat(this.tube),parseInt(this.tubularSegments,10),parseInt(this.radialSegments,10),parseInt(this.p,10),parseInt(this.q,10))}}},e.VglArrowHelper={mixins:[B],props:{/** Direction from origin. */dir:M,/** Length of the arrow. */length:{type:N,default:1},/** Color of the arrow. */color:{type:w,default:"#ff0"},/** The length of the head of the arrow. */headLength:N,/** The width of the head of the arrow. */headWidth:N},computed:{inst:function(){return new t.ArrowHelper(new t.Vector3(0,1,0),new t.Vector3())},len:function(){return[parseFloat(this.length),this.headLength===void 0?void 0:parseFloat(this.headLength),this.headWidth===void 0?void 0:parseFloat(this.headWidth)]}},watch:{inst:{handler:function(e){this.dir&&e.setDirection(g(this.dir).normalize()),e.setLength.apply(e,s(this.len)),e.setColor(new t.Color(this.color))},immediate:!0},dir:function(e){this.inst.setDirection(g(e).normalize())},len:function(e){var t;(t=this.inst).setLength.apply(t,s(e))},color:function(e){this.inst.setColor(new t.Color(e))}}},e.VglBoxHelper={mixins:[B],props:{/** Size of the lines representing the axes. */color:{type:w,default:"#ff0"},/** Name of the object to show the world-axis-aligned boundingbox. */object:w},computed:{inst:function(){return new t.BoxHelper(void 0,this.color)}},methods:{setFromObject:function(){this.inst.setFromObject(this.vglNamespace.object3ds[this.object])}},created:function(){this.vglNamespace.beforeRender.push(this.setFromObject)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setFromObject;e.splice(e.indexOf(t),1)}},e.VglPointLight={mixins:[D],props:{/**
       * The distance from the light where the intensity is 0.
       * When set to 0, then the light never stops.
       */distance:{type:N,default:0},/**
       * The amount the light dims along the distance of the light.
       * For physically correct lighting, set this to 2.
       */decay:{type:N,default:1}},computed:{inst:function(){return new t.PointLight}},watch:{inst:{handler:function(e){Object.assign(e,{distance:parseFloat(this.distance),decay:parseFloat(this.decay)})},immediate:!0},distance:function(e){this.inst.distance=parseFloat(e)},decay:function(e){this.inst.decay=parseFloat(e)}}},e.VglSpotLight={mixins:[D],props:{/**
       * The distance from the light where the intensity is 0.
       * When set to 0, then the light never stops.
       */distance:{type:N,default:0},/**
       * The amount the light dims along the distance of the light.
       * For physically correct lighting, set this to 2.
       */decay:{type:N,default:1},/**
       * Maximum extent of the spotlight, in radians, from its direction.
       * Should be no more than Math.PI/2.
       */angle:{type:N,default:S/3},/**
       * Percent of the spotlight cone that is attenuated due to penumbra.
       * Takes values between zero and 1.
       */penumbra:{type:N,default:0},/** The spotlight's pointing position. */target:M},computed:{inst:function(){return new t.SpotLight}},beforeDestroy:function(){this.inst.target.parent&&this.inst.target.parent.remove(this.inst.target)},watch:{inst:{handler:function(e){Object.assign(e,{distance:parseFloat(this.distance),decay:parseFloat(this.decay),angle:parseFloat(this.angle),penumbra:parseFloat(this.penumbra)}),this.target&&e.target.position.copy(g(this.target)),this.vglObject3d.inst&&this.vglObject3d.inst.add(e.target)},immediate:!0},"vglObject3d.inst":function(e){e.add(this.inst.target)},distance:function(e){this.inst.distance=parseFloat(e)},decay:function(e){this.inst.decay=parseFloat(e)},angle:function(e){this.inst.angle=parseFloat(e)},penumbra:function(e){this.inst.penumbra=parseFloat(e)},target:function(e){this.inst.target.position.copy(g(e))}}},e.VglTexture={inject:["vglNamespace"],props:{/** The path or URL to the file. This can also be a Data URI. */src:w,name:w,mapping:{type:w,default:"uv"},wrapS:{type:w,default:"clamp-to-edge"},wrapT:{type:w,default:"clamp-to-edge"},magFilter:{type:w,default:"linear"},minFilter:{type:w,default:"linear-mip-map-linear"},anisotropy:{type:N,default:1},format:w,type:{type:w,default:"unsigned-byte"},offset:G,repeat:G,rotation:{type:N,default:0},center:G,premultiplyAlpha:L,unpackAlignment:{type:N,default:4},encoding:{type:w,default:"linear"}},computed:{inst:function(){var e=this;return new t.TextureLoader().load(this.src,function(t){e.format&&Object.assign(t,{format:Q[e.format]}),e.vglNamespace.update()})}},watch:{inst:{handler:function(e){this.vglNamespace.textures[this.name]=e,Object.assign(e,{mapping:_[this.mapping],wrapS:I[this.wrapS],wrapT:I[this.wrapT],magFilter:q[this.magFilter],minFilter:q[this.minFilter],anisotropy:parseInt(this.anisotropy,10),type:K[this.type],rotation:parseFloat(this.rotation),premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:parseInt(this.unpackAlignment,10),encoding:J[this.encoding]}),this.offset&&e.offset.copy(h(this.offset)),this.repeat&&e.repeat.copy(h(this.repeat)),this.center&&e.center.copy(h(this.center))},immediate:!0},name:function(e,t){var i=this.vglNamespace.textures,a=this.inst;i[t]===a&&delete i[t],i[e]=a},mapping:function(e){this.inst.mapping=_[e]},wrapS:function(e){this.inst.wrapS=I[e]},wrapT:function(e){this.inst.wrapT=I[e]},magFilter:function(e){this.inst.magFilter=q[e]},minFilter:function(e){this.inst.minFilter=q[e]},anisotropy:function(e){this.inst.anisotropy=parseInt(e,10)},format:function(e){this.inst.format=Q[e]},type:function(e){this.inst.type=K[e]},offset:function(e){this.inst.offset.copy(h(e))},repeat:function(e){this.inst.repeat.copy(h(e))},rotation:function(e){this.inst.rotation=parseFloat(e)},center:function(e){this.inst.center.copy(h(e))},premultiplyAlpha:function(e){this.inst.premultiplyAlpha=e},unpackAlignment:function(e){this.inst.unpackAlignment=parseInt(e,10)},encoding:function(e){this.inst.encoding=J[e]}},beforeDestroy:function(){var e=this.vglNamespace.textures,t=this.inst,i=this.name;e[i]===t&&delete e[i]},beforeUpdate:function(){this.inst.needsUpdate=!0,this.vglNamespace.update()},render:function(e){return this.$slots.default?e("div",this.$slots.default):void 0}},e.VglExtrudeGeometry=X,e.VglTextGeometry={mixins:[X],props:{/** The text that needs to be shown. */text:{type:w,default:""},/** The path or URL to the facetype json file. This can also be a Data URI. */font:w,/** Size of the text. */size:{type:N,default:100},/** Thickness to extrude text. */height:{type:N,default:50},/** Number of points on the curves. */curveSegments:{type:N,default:12},/** Turn on bevel. */bevelEnabled:L,/** How deep into text bevel goes. */bevelThickness:{type:N,default:10},/** How far from text outline is bevel. */bevelSize:{type:N,default:8},/** Number of bevel segments. */bevelSegments:{type:N,default:3}},data:function(){return{f:void 0}},computed:{inst:function(){return this.f===void 0?new t.BufferGeometry:new t.TextBufferGeometry(this.text,{font:Y[this.f],size:parseFloat(this.size),height:parseFloat(this.height),curveSegments:parseInt(this.curveSegments,10),bevelEnabled:this.bevelEnabled,bevelThickness:parseFloat(this.bevelThickness),bevelSize:parseFloat(this.bevelSize),bevelSegments:parseInt(this.bevelSegments,10)})}},watch:{font:{handler:function(e){var i=this;Y[e]?Y[e].isFont?this.f=e:Y[e].push(function(){e===i.font&&(i.f=e)}):(Y[e]=[function(){e===i.font&&(i.f=e),i.vglNamespace.update()}],new t.FontLoader().load(e,function(t){var i=Y[e];Y[e]=t,i.forEach(function(e){e()})}))},immediate:!0}}},e.VglSpriteMaterial={mixins:[$],props:{/** CSS style color of the material. */color:{type:w,default:"#fff"},/** The texture map of the material. */map:w},computed:{inst:function(){return new t.SpriteMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)}}},e.VglGridHelper={mixins:[B],props:{/** The size of the grid. */size:{type:N,default:10},/** The number of divisions across the grid. */divisions:{type:N,default:10},/** The color of the centerline. */colorCenterLine:{type:w,default:"#444444"},/** The color of the lines of the grid. */colorGrid:{type:w,default:"#888888"}},computed:{inst:function(){return new t.GridHelper(parseFloat(this.size),parseInt(this.divisions,10),this.colorCenterLine,this.colorGrid)}}},e.VglShadowMaterial={mixins:[H],computed:{inst:function(){return new t.ShadowMaterial}}},e.VglCameraHelper={mixins:[B],props:{/** Name of the camera to visualize. */camera:w},methods:{setHelper:function(){if(!this.inst.children.length)this.inst.add(new t.CameraHelper(this.vglNamespace.cameras[this.camera]));else{var e=n(this.inst.children,1),i=e[0];i.camera=this.vglNamespace.cameras[this.camera],i.camera.updateProjectionMatrix(),i.update()}}},created:function(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setHelper;e.splice(e.indexOf(t),1)}},e.VglDirectionalLightHelper={mixins:[B],props:{/** If this is not the set the helper will take the color of the light. */color:{type:w},/** Dimensions of the plane. */size:{type:N,default:1},/** Name of the directional light being visualized. */light:w},data:function(){return{s:void 0}},methods:{setHelper:function(){var e=this.vglNamespace.object3ds[this.light];if(this.inst.children.length){var i=n(this.inst.children,1),a=i[0];if(a.light===e&&this.s===this.size)return a.color=this.color,void a.update();this.inst.remove(a)}this.s=this.size,this.inst.add(new t.DirectionalLightHelper(e,parseFloat(this.size),this.color))}},created:function(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setHelper;e.splice(e.indexOf(t),1)}},e.VglPolarGridHelper={mixins:[B],props:{/** The radius of the polar grid. This can be any positive number. */radius:{type:N,default:10},/** The number of radial lines. This can be any positive integer. */radials:{type:N,default:16},/** The number of circles. This can be any positive integer. */circles:{type:N,default:8},/**
       * The number of line segments used for each circle.
       * This can be any positive integer that is 3 or greater.
       */divisions:{type:N,default:64},/** The first color used for grid elements. */color1:{type:w,default:"#444444"},/** The second color used for grid elements. */color2:{type:w,default:"#888888"}},computed:{inst:function(){return new t.PolarGridHelper(parseFloat(this.radius),parseInt(this.radials,10),parseInt(this.circles,10),parseInt(this.divisions,10),this.color1,this.color2)}}},e.VglRectAreaLightHelper={mixins:[B],props:{/** If this is not the set the helper will take the color of the light. */color:{type:w},/** Name of the RectAreaLight being visualized. */light:{type:w,required:!0}},methods:{setHelper:function(){var e=this.vglNamespace.object3ds[this.light];if(this.inst.children.length){var i=n(this.inst.children,1),a=i[0];if(a.light===e)return a.color=this.color,void a.update();this.inst.remove(a)}this.inst.add(new t.RectAreaLightHelper(e,this.color))}},created:function(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setHelper;e.splice(e.indexOf(t),1)}},e.VglMeshBasicMaterial={mixins:[$],props:{/** CSS style color of the material. */color:{type:w,default:"#fff"},/** The color map of the material. */map:w},computed:{inst:function(){return new t.MeshBasicMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)}}},e.VglMeshDepthMaterial={mixins:[$],props:{/** Whether the material is affected by fog. */fog:L,/** The color map of the material. */map:w},computed:{inst:function(){return new t.MeshDepthMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{fog:this.fog})},immediate:!0},fog:function(e){this.inst.fog=e}}},e.VglMeshLambertMaterial={mixins:[$],props:{/** CSS style color of the material. */color:{type:w,default:"#fff"},/** The color map of the material. */map:w},computed:{inst:function(){return new t.MeshLambertMaterial}},watch:{inst:{handler:function(e){e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)}}},e.VglLineDashedMaterial={mixins:[H],props:{/** CSS style color of the material. */color:{type:w,default:"#fff"},/** A boolean whether the material is affected by lights. */lights:L,/** The line thickness. */linewidth:{type:N,default:1},/** The size of the dash. This is both the gap with the stroke. */dashSize:{type:N,default:3},/** The size of the gap. */gapSize:{type:N,default:1}},computed:{inst:function(){return new t.LineDashedMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{lights:this.lights,dashSize:parseFloat(this.dashSize),gapSize:parseFloat(this.gapSize),linewidth:parseFloat(this.linewidth)}),e.color.setStyle(this.color)},immediate:!0},color:function(e){this.inst.color.setStyle(e)},lights:function(e){this.inst.lights=e},linewidth:function(e){this.inst.linewidth=parseFloat(e)},dashSize:function(e){this.inst.dashSize=parseFloat(e)},gapSize:function(e){this.inst.gapSize=parseFloat(e)}}},e.VglMeshNormalMaterial={mixins:[H],props:{/** Whether the material is affected by fog. */fog:L},computed:{inst:function(){return new t.MeshNormalMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{fog:this.fog})},immediate:!0},fog:function(e){this.inst.fog=e}}},e.VglMeshPhongMaterial=Z,e.VglMeshToonMaterial={mixins:[Z],computed:{inst:function(){return new t.MeshToonMaterial}}},e.VglMeshPhysicalMaterial={mixins:[k],props:{/** ClearCoat level, from 0.0 to 1.0. */clearCoat:{type:N,default:0},/** How rough the clearCoat appears, from 0.0 to 1.0. */clearCoatRoughness:{type:N,default:0},/** Degree of reflectivity, from 0.0 to 1.0. */reflectivity:{type:N,default:.5}},computed:{inst:function(){return new t.MeshPhysicalMaterial}},watch:{inst:{handler:function(e){Object.assign(e,{clearCoat:parseFloat(this.clearCoat),clearCoatRoughness:parseFloat(this.clearCoatRoughness),reflectivity:parseFloat(this.reflectivity)})},immediate:!0},clearCoat:function(e){this.inst.clearCoat=parseFloat(e)},clearCoatRoughness:function(e){this.inst.clearCoatRoughness=parseFloat(e)},reflectivity:function(e){this.inst.reflectivity=parseFloat(e)}}},e.VglLatheGeometry={mixins:[F],props:{/** Array of Vector2s. The x-coordinate of each point must be greater than zero. */points:{type:j,required:!0},/** The number of circumference segments to generate. */segments:{type:N,default:12},/** The starting angle in radians. */phiStart:{type:N,default:0},/** The radian (0 to 2PI) range of the lathed section. */phiLength:{type:N,default:2*S}},computed:{inst:function(){return new t.LatheBufferGeometry(v(this.points),parseInt(this.segments,10),parseFloat(this.phiStart),parseFloat(this.phiLength))}}},e.VglSpotLightHelper={mixins:[B],props:{/** If this is not the set the helper will take the color of the light. */color:{type:w},/** Name of the spot light being visualized. */light:w},methods:{setHelper:function(){if(this.inst.children.length){var e=n(this.inst.children,1),i=e[0];i.light===this.vglNamespace.object3ds[this.light]?(i.color=this.color,i.update()):(this.inst.remove(i),i.dispose(),this.inst.add(new t.SpotLightHelper(this.vglNamespace.object3ds[this.light],this.color)))}else this.inst.add(new t.SpotLightHelper(this.vglNamespace.object3ds[this.light],this.color))}},created:function(){this.vglNamespace.beforeRender.push(this.setHelper)},beforeDestroy:function(){var e=this.vglNamespace.beforeRender,t=this.setHelper,i=this.inst.children;e.splice(e.indexOf(t),1),i.length&&i[0].dispose()}},e.VglHemisphereLight={mixins:[D],props:{groundColor:{type:w,default:"#fff"}},computed:{inst:function(){return new t.HemisphereLight}},watch:{inst:{handler:function(e){e.groundColor.setStyle(this.groundColor)},immediate:!0},groundColor:function(e){this.inst.groundColor.setStyle(e)}}},e.VglRectAreaLight={mixins:[D],props:{/** Width of the light. */width:{type:N,default:10},/** Height of the light. */height:{type:N,default:10}},computed:{inst:function(){return new t.RectAreaLight}},watch:{inst:{handler:function(e){Object.assign(e,{width:parseFloat(this.width),height:parseFloat(this.height)})},immediate:!0},width:function(e){this.inst.width=parseFloat(e)},height:function(e){this.inst.height=parseFloat(e)}}},Object.defineProperty(e,"__esModule",{value:!0})});
